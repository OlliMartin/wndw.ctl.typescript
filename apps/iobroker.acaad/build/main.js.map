{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.6.5\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from '@iobroker/adapter-core';\n\ninterface AdapterConfig {\n  option1: boolean;\n  option2: string;\n}\n\n// Load your modules here, e.g.:\n// import * as fs from \"fs\";\n\nclass Acaad extends utils.Adapter {\n  public constructor(options: Partial<utils.AdapterOptions> = {}) {\n    super({\n      ...options,\n      name: 'acaad',\n    });\n    this.on('ready', this.onReady.bind(this));\n    this.on('stateChange', this.onStateChange.bind(this));\n    // this.on('objectChange', this.onObjectChange.bind(this));\n    // this.on('message', this.onMessage.bind(this));\n    this.on('unload', this.onUnload.bind(this));\n  }\n\n  /**\n   * Is called when databases are connected and adapter received configuration.\n   */\n  private async onReady(): Promise<void> {\n    // Initialize your adapter here\n\n    // The adapters config (in the instance object everything under the attribute \"native\") is accessible via\n    // this.config:\n    this.log.info('config option1: ' + (this.config as AdapterConfig).option1);\n    this.log.info('config option2: ' + (this.config as AdapterConfig).option2);\n\n    /*\n        For every state in the system there has to be also an object of type state\n        Here a simple template for a boolean variable named \"testVariable\"\n        Because every adapter instance uses its own unique namespace variable names can't collide with other adapters variables\n        */\n    await this.setObjectNotExistsAsync('testVariable', {\n      type: 'state',\n      common: {\n        name: 'testVariable',\n        type: 'boolean',\n        role: 'indicator',\n        read: true,\n        write: true,\n      },\n      native: {},\n    });\n\n    // In order to get state updates, you need to subscribe to them. The following line adds a subscription for our variable we have created above.\n    this.subscribeStates('testVariable');\n    // You can also add a subscription for multiple states. The following line watches all states starting with \"lights.\"\n    // this.subscribeStates('lights.*');\n    // Or, if you really must, you can also watch all states. Don't do this if you don't need to. Otherwise this will cause a lot of unnecessary load on the system:\n    // this.subscribeStates('*');\n\n    /*\n            setState examples\n            you will notice that each setState will cause the stateChange event to fire (because of above subscribeStates cmd)\n        */\n    // the variable testVariable is set to true as command (ack=false)\n    this.setState('testVariable', true);\n\n    // same thing, but the value is flagged \"ack\"\n    // ack should be always set to true if the value is received from or acknowledged from the target system\n    this.setState('testVariable', { val: true, ack: true });\n\n    // same thing, but the state is deleted after 30s (getState will return null afterwards)\n    this.setState('testVariable', {\n      val: true,\n      ack: true,\n      expire: 30,\n    });\n\n    // examples for the checkPassword/checkGroup functions\n    let result = await this.checkPasswordAsync('admin', 'iobroker');\n    this.log.info('check user admin pw iobroker: ' + result);\n\n    result = await this.checkGroupAsync('admin', 'admin');\n    this.log.info('check group user admin group admin: ' + result);\n  }\n\n  /**\n   * Is called when adapter shuts down - callback has to be called under any circumstances!\n   */\n  private onUnload(callback: () => void): void {\n    try {\n      // Here you must clear all timeouts or intervals that may still be active\n      // clearTimeout(timeout1);\n      // clearTimeout(timeout2);\n      // ...\n      // clearInterval(interval1);\n\n      callback();\n    } catch (e) {\n      callback();\n    }\n  }\n\n  // If you need to react to object changes, uncomment the following block and the corresponding line in the constructor.\n  // You also need to subscribe to the objects with `this.subscribeObjects`, similar to `this.subscribeStates`.\n  // /**\n  //  * Is called if a subscribed object changes\n  //  */\n  // private onObjectChange(id: string, obj: ioBroker.Object | null | undefined): void {\n  //     if (obj) {\n  //         // The object was changed\n  //         this.log.info(`object ${id} changed: ${JSON.stringify(obj)}`);\n  //     } else {\n  //         // The object was deleted\n  //         this.log.info(`object ${id} deleted`);\n  //     }\n  // }\n\n  /**\n   * Is called if a subscribed state changes\n   */\n  private onStateChange(\n    id: string,\n    state: ioBroker.State | null | undefined\n  ): void {\n    if (state) {\n      // The state was changed\n      this.log.info(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\n    } else {\n      // The state was deleted\n      this.log.info(`state ${id} deleted`);\n    }\n  }\n\n  // If you need to accept messages in your adapter, uncomment the following block and the corresponding line in the constructor.\n  // /**\n  //  * Some message was sent to this instance over message box. Used by email, pushover, text2speech, ...\n  //  * Using this method requires \"common.messagebox\" property to be set to true in io-package.json\n  //  */\n  // private onMessage(obj: ioBroker.Message): void {\n  //     if (typeof obj === 'object' && obj.message) {\n  //         if (obj.command === 'send') {\n  //             // e.g. send email or pushover or whatever\n  //             this.log.info('send command');\n\n  //             // Send response in callback if required\n  //             if (obj.callback) this.sendTo(obj.from, obj.command, 'Message received', obj.callback);\n  //         }\n  //     }\n  // }\n}\n\nif (require.main !== module) {\n  // Export the constructor in compact mode\n  module.exports = (options: Partial<utils.AdapterOptions> | undefined) =>\n    new Acaad(options);\n} else {\n  // otherwise start the instance directly\n  (() => new Acaad())();\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAMA,YAAuB;AAUvB,MAAM,cAAc,MAAM,QAAQ;AAAA,EACzB,YAAY,UAAyC,CAAC,GAAG;AAC9D,UAAM;AAAA,MACJ,GAAG;AAAA,MACH,MAAM;AAAA,IACR,CAAC;AACD,SAAK,GAAG,SAAS,KAAK,QAAQ,KAAK,IAAI,CAAC;AACxC,SAAK,GAAG,eAAe,KAAK,cAAc,KAAK,IAAI,CAAC;AAGpD,SAAK,GAAG,UAAU,KAAK,SAAS,KAAK,IAAI,CAAC;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,UAAyB;AAKrC,SAAK,IAAI,KAAK,qBAAsB,KAAK,OAAyB,OAAO;AACzE,SAAK,IAAI,KAAK,qBAAsB,KAAK,OAAyB,OAAO;AAOzE,UAAM,KAAK,wBAAwB,gBAAgB;AAAA,MACjD,MAAM;AAAA,MACN,QAAQ;AAAA,QACN,MAAM;AAAA,QACN,MAAM;AAAA,QACN,MAAM;AAAA,QACN,MAAM;AAAA,QACN,OAAO;AAAA,MACT;AAAA,MACA,QAAQ,CAAC;AAAA,IACX,CAAC;AAGD,SAAK,gBAAgB,cAAc;AAWnC,SAAK,SAAS,gBAAgB,IAAI;AAIlC,SAAK,SAAS,gBAAgB,EAAE,KAAK,MAAM,KAAK,KAAK,CAAC;AAGtD,SAAK,SAAS,gBAAgB;AAAA,MAC5B,KAAK;AAAA,MACL,KAAK;AAAA,MACL,QAAQ;AAAA,IACV,CAAC;AAGD,QAAI,SAAS,MAAM,KAAK,mBAAmB,SAAS,UAAU;AAC9D,SAAK,IAAI,KAAK,mCAAmC,MAAM;AAEvD,aAAS,MAAM,KAAK,gBAAgB,SAAS,OAAO;AACpD,SAAK,IAAI,KAAK,yCAAyC,MAAM;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA,EAKQ,SAAS,UAA4B;AAC3C,QAAI;AAOF,eAAS;AAAA,IACX,SAAS,GAAG;AACV,eAAS;AAAA,IACX;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAoBQ,cACN,IACA,OACM;AACN,QAAI,OAAO;AAET,WAAK,IAAI,KAAK,SAAS,EAAE,aAAa,MAAM,GAAG,WAAW,MAAM,GAAG,GAAG;AAAA,IACxE,OAAO;AAEL,WAAK,IAAI,KAAK,SAAS,EAAE,UAAU;AAAA,IACrC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBF;AAEA,IAAI,QAAQ,SAAS,QAAQ;AAE3B,SAAO,UAAU,CAAC,YAChB,IAAI,MAAM,OAAO;AACrB,OAAO;AAEL,GAAC,MAAM,IAAI,MAAM,GAAG;AACtB;",
  "names": []
}
